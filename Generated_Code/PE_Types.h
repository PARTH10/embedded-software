/* ###################################################################
**     This component module is generated by Processor Expert. Do not modify it.
**     Filename    : PE_Types.h
**     Project     : Lab1
**     Processor   : MK70FN1M0VMJ12
**     Component   : PE_Types
**     Version     : Driver 01.01
**     Compiler    : GNU C Compiler
**     Date/Time   : 2015-07-23, 17:34, # CodeGen: 6
**     Abstract    :
**         PE_Types.h - contains definitions of basic types,
**         register access macros and hardware specific macros
**         which can be used in user application.
**     Contents    :
**         No public methods
**
**     Copyright : 1997 - 2015 Freescale Semiconductor, Inc. 
**     All Rights Reserved.
**     
**     Redistribution and use in source and binary forms, with or without modification,
**     are permitted provided that the following conditions are met:
**     
**     o Redistributions of source code must retain the above copyright notice, this list
**       of conditions and the following disclaimer.
**     
**     o Redistributions in binary form must reproduce the above copyright notice, this
**       list of conditions and the following disclaimer in the documentation and/or
**       other materials provided with the distribution.
**     
**     o Neither the name of Freescale Semiconductor, Inc. nor the names of its
**       contributors may be used to endorse or promote products derived from this
**       software without specific prior written permission.
**     
**     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
**     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
**     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
**     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
**     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
**     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
**     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
**     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
**     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**     
**     http: www.freescale.com
**     mail: support@freescale.com
** ###################################################################*/
/*!
** @file PE_Types.h
** @version 01.01
** @brief
**         PE_Types.h - contains definitions of basic types,
**         register access macros and hardware specific macros
**         which can be used in user application.
*/         
/*!
**  @addtogroup PE_Types_module PE_Types module documentation
**  @{
*/         

#ifndef __PE_Types_H
#define __PE_Types_H

/* Standard ANSI C types */
#include <stdint.h>

#ifndef FALSE
  #define  FALSE  0x00u                /* Boolean value FALSE. FALSE is defined always as a zero value. */
#endif
#ifndef TRUE
  #define  TRUE   0x01u                /* Boolean value TRUE. TRUE is defined always as a non zero value. */
#endif

#ifndef NULL
  #define  NULL   0x00u
#endif

/* PE types definition */
#ifndef __cplusplus
  #ifndef bool 
typedef unsigned char           bool;
  #endif
#endif
typedef unsigned char           byte;
typedef unsigned short          word;
typedef unsigned long           dword;
typedef unsigned long long      dlong;
typedef unsigned char           TPE_ErrCode;
#ifndef TPE_Float
typedef float                   TPE_Float;
#endif
#ifndef char_t
typedef char                    char_t;
#endif

/* Other basic data types */
typedef signed char             int8;
typedef signed short int        int16;
typedef signed long int         int32;

typedef unsigned char           uint8;
typedef unsigned short int      uint16;
typedef unsigned long int       uint32;


/**********************************************************/
/* Uniform multiplatform 8-bits peripheral access macros */
/**********************************************************/

/* Enable maskable interrupts */
#define __EI()\
 do {\
  /*lint -save  -e950 Disable MISRA rule (1.1) checking. */\
     __asm("CPSIE f");\
  /*lint -restore Enable MISRA rule (1.1) checking. */\
 } while(0)

/* Disable maskable interrupts */
#define __DI() \
 do {\
  /*lint -save  -e950 Disable MISRA rule (1.1) checking. */\
     __asm ("CPSID f");\
  /*lint -restore Enable MISRA rule (1.1) checking. */\
 } while(0)



/* Save status register and disable interrupts */
#define EnterCritical() \
 do {\
  uint8_t SR_reg_local;\
  /*lint -save  -e586 -e950 Disable MISRA rule (2.1,1.1) checking. */\
   __asm ( \
   "MRS R0, FAULTMASK\n\t" \
   "CPSID f\n\t"            \
   "STRB R0, %[output]"  \
   : [output] "=m" (SR_reg_local)\
   :: "r0");\
  /*lint -restore Enable MISRA rule (2.1,1.1) checking. */\
   if (++SR_lock == 1u) {\
     SR_reg = SR_reg_local;\
   }\
 } while(0)

 
/* Restore status register  */
#define ExitCritical() \
 do {\
   if (--SR_lock == 0u) { \
  /*lint -save  -e586 -e950 Disable MISRA rule (2.1,1.1) checking. */\
     __asm (                 \
       "ldrb r0, %[input]\n\t"\
       "msr FAULTMASK,r0;\n\t" \
       ::[input] "m" (SR_reg)  \
       : "r0");                \
  /*lint -restore Enable MISRA rule (2.1,1.1) checking. */\
   }\
 } while(0)


#define PE_DEBUGHALT() \
  /*lint -save  -e586 -e950 Disable MISRA rule (2.1,1.1) checking. */\
  __asm( "BKPT 255") \
  /*lint -restore Enable MISRA rule (2.1,1.1) checking. */

#define PE_NOP() \
  /*lint -save  -e586 -e950 Disable MISRA rule (2.1,1.1) checking. */\
  __asm( "NOP") \
  /*lint -restore Enable MISRA rule (2.1,1.1) checking. */

#define PE_WFI() \
  /*lint -save  -e586 -e950 Disable MISRA rule (2.1,1.1) checking. */\
  __asm("WFI") \
  /*lint -restore Enable MISRA rule (2.1,1.1) checking. */


/* Interrupt definition template */
#if !defined(PE_ISR)
  #define PE_ISR(ISR_name) void __attribute__ ((interrupt)) ISR_name(void)
#endif

/* Logical Device Drivers (LDD) types */

/*! Logical Device Driver API version */
#define PE_LDD_VERSION                           0x0100U

/* LDD driver states */
#define PE_LDD_DRIVER_DISABLED_IN_CLOCK_CONFIGURATION 0x01U /*!< LDD driver is disabled in the selected clock configuration */
#define PE_LDD_DRIVER_DISABLED_BY_USER           0x02U /*!< LDD driver is disabled by the user */
#define PE_LDD_DRIVER_BUSY                       0x04U /*!< LDD driver is busy */

/*! Macro to register component device structure */
#define PE_LDD_RegisterDeviceStructure(ComponentIndex, DeviceStructure) (PE_LDD_DeviceDataList[ComponentIndex] = DeviceStructure)

/*! Macro to unregister component device structure */
#define PE_LDD_UnregisterDeviceStructure(ComponentIndex) (PE_LDD_DeviceDataList[ComponentIndex] = NULL)

/*! Macro to get the component device structure */
#define PE_LDD_GetDeviceStructure(ComponentIndex) (PE_LDD_DeviceDataList[ComponentIndex])

/*
** ===================================================================
** Global HAL types and constants
** ===================================================================
*/
typedef uint32_t LDD_TPinMask;         /*!< Pin mask type. */
typedef uint16_t LDD_TError;           /*!< Error type. */
typedef uint32_t LDD_TEventMask;       /*!< Event mask type. */
typedef uint8_t LDD_TClockConfiguration; /*!< CPU clock configuration type. */
typedef void LDD_TDeviceData;          /*!< Pointer to private device structure managed and used by HAL components. */
typedef void* LDD_TDeviceDataPtr;      /*!< Obsolete type for backward compatibility. */
typedef void LDD_TData;                /*!< General pointer to data. */
typedef void LDD_TUserData;            /*!< Pointer to this type specifies the user or RTOS specific data will be passed as an event or callback parameter. */

/*! Driver operation mode type. */
typedef enum {
  DOM_NONE,
  DOM_RUN,
  DOM_WAIT,
  DOM_SLEEP,
  DOM_STOP
} LDD_TDriverOperationMode;

typedef uint16_t LDD_TDriverState;     /*!< Driver state type. */
typedef void LDD_TCallbackParam;       /*!< Pointer to this type specifies the user data to be passed as a callback parameter. */
typedef void (* LDD_TCallback)(LDD_TCallbackParam *CallbackParam); /*!< Callback type used for definition of callback functions. */


/* Fills a memory area block by a specified value. Function defined in PE_LDD.c */
extern void PE_FillMemory(register void* SourceAddressPtr, register uint8_t c, register uint32_t len);


/*
** ===================================================================
** RTOS specific types and constants
** ===================================================================
*/
/* {Default RTOS Adapter} RTOS specific definition of type of Ioctl() command constants */


/*
** ===================================================================
** Published RTOS settings and constants
** ===================================================================
*/
/* {Default RTOS Adapter} No published RTOS settings */


/*
** ===================================================================
** TimerUnit device types and constants
** ===================================================================
*/
#define LDD_TIMERUNIT_ON_CHANNEL_0             0x01u /*!< OnChannel0 event mask value */
#define LDD_TIMERUNIT_ON_CHANNEL_1             0x02u /*!< OnChannel1 event mask value */
#define LDD_TIMERUNIT_ON_CHANNEL_2             0x04u /*!< OnChannel2 event mask value */
#define LDD_TIMERUNIT_ON_CHANNEL_3             0x08u /*!< OnChannel3 event mask value */
#define LDD_TIMERUNIT_ON_CHANNEL_4             0x10u /*!< OnChannel4 event mask value */
#define LDD_TIMERUNIT_ON_CHANNEL_5             0x20u /*!< OnChannel5 event mask value */
#define LDD_TIMERUNIT_ON_CHANNEL_6             0x40u /*!< OnChannel6 event mask value */
#define LDD_TIMERUNIT_ON_CHANNEL_7             0x80u /*!< OnChannel7 event mask value */
#define LDD_TIMERUNIT_ON_COUNTER_RESTART       0x0100u /*!< OnCounterRestart event mask value */

/*! Direction of counting */
typedef enum {
  DIR_UP,                              /*!< UP */
  DIR_DOWN                             /*!< DOWN */
} LDD_TimerUnit_TCounterDirection;

/*! Output action type (flip-flop action on overrun or compare match) */
typedef enum                          {
  OUTPUT_NONE,                         /*!< NONE */
  OUTPUT_TOGGLE,                       /*!< TOGGLE */
  OUTPUT_CLEAR,                        /*!< CLEAR */
  OUTPUT_SET                           /*!< SET */
} LDD_TimerUnit_TOutAction;

/*! Input edge type */
typedef enum  {
  EDGE_NONE,                           /*!< NONE */
  EDGE_RISING,                         /*!< RISING */
  EDGE_FALLING,                        /*!< FALLING */
  EDGE_BOTH                            /*!< BOTH */
} LDD_TimerUnit_TEdge;

typedef float LDD_TimerUnit_Tfloat;    /*!< Float type */

/*
** ===================================================================
** CMT device types and constants
** ===================================================================
*/
#define LDD_CMT_ON_END                         0x01u /*!< OnEnd event mask value */

/*
** ===================================================================
** PPG device types and constants
** ===================================================================
*/
#define LDD_PPG_ON_END                         0x01u /*!< OnEnd event mask value */

typedef float LDD_PPG_Tfloat;          /*!< Float type */

/*
** ===================================================================
** PWM types and constants
** ===================================================================
*/
#define LDD_PWM_ON_END                         0x01u /*!< OnEnd event mask value */

/*
** ===================================================================
** Capture types and constants
** ===================================================================
*/
#define LDD_CAPTURE_ON_CAPTURE                 0x01u /*!< OnCapture event mask value */
#define LDD_CAPTURE_ON_OVERRUN                 0x02u /*!< OnOverrun event mask value */

/*
** ===================================================================
** TimerInt types and constants
** ===================================================================
*/
#define LDD_TIMERINT_ON_INTERRUPT              0x01u /*!< OnInterrupt event mask value */

/*
** ===================================================================
** TimerOut types and constants
** ===================================================================
*/
#define LDD_TIMEROUT_ON_INTERRUPT              0x01u /*!< OnInterrupt event mask value */

/*
** ===================================================================
** EventCntr types and constants
** ===================================================================
*/
#define LDD_EVENTCNTR_ON_END                   0x01u /*!< OnEnd event mask value */

/*
** ===================================================================
** FreeCntr types and constants
** ===================================================================
*/
#define LDD_FREECNTR_ON_INTERRUPT              0x01u /*!< OnInterrupt event mask value */

/*
** ===================================================================
** RealTime types and constants
** ===================================================================
*/

typedef float LDD_RealTime_Tfloat;     /*!< Float type */

/*
** ===================================================================
** TimeDate types and constants
** ===================================================================
*/
#define LDD_TIMEDATE_ON_ALARM         0x01u /*!< OnAlarm event mask value */
#define LDD_TIMEDATE_ON_SECOND        0x02u /*!< OnSecond event mask value */

/*!< Time struct */
typedef struct {
  uint16_t Hour;                       /*!< Hours (0 - 23) */
  uint16_t Min;                        /*!< Minutes (0 - 59) */
  uint16_t Sec;                        /*!< Seconds (0 - 59) */
  uint16_t Sec100;                     /*!< Hundredths of seconds (0 - 99) */
} LDD_TimeDate_TTimeRec;

/*!< Date struct */
typedef struct {
  uint16_t Year;                       /*!< Years (1998 - 2099) */
  uint16_t Month;                      /*!< Months (1 - 12) */
  uint16_t Day;                        /*!< Days (1 - 31) */
  uint16_t DayOfWeek;                  /*!< Day of week (0-Sunday, .. 6-Saturday)  */
} LDD_TimeDate_TDateRec;

/*
** ===================================================================
** UART device types and constants
** ===================================================================
*/
#define LDD_SERIAL_RX_PIN                      0x01u /*!< Receiver pin mask */
#define LDD_SERIAL_TX_PIN                      0x02u /*!< Transmitter pin mask */
#define LDD_SERIAL_CTS_PIN                     0x04u /*!< CTS pin mask */
#define LDD_SERIAL_RTS_PIN                     0x08u /*!< RTS pin mask */

#define LDD_SERIAL_ON_BLOCK_RECEIVED           0x01u /*!< OnBlockReceived event mask */
#define LDD_SERIAL_ON_BLOCK_SENT               0x02u /*!< OnBlockSent event mask */
#define LDD_SERIAL_ON_BREAK                    0x04u /*!< OnBreak event mask */
#define LDD_SERIAL_ON_TXCOMPLETE               0x08u /*!< OnTxComplete event mask */
#define LDD_SERIAL_ON_ERROR                    0x10u /*!< OnError event mask */

#define LDD_SERIAL_RX_OVERRUN                  0x01u /*!< Receiver overrun */
#define LDD_SERIAL_PARITY_ERROR                0x02u /*!< Parity error */
#define LDD_SERIAL_FRAMING_ERROR               0x04u /*!< Framing error */
#define LDD_SERIAL_NOISE_ERROR                 0x08u /*!< Noise error */

typedef uint32_t LDD_SERIAL_TError;    /*!< Serial communication error type */

typedef uint8_t LDD_SERIAL_TDataWidth; /*!< Bit length type. The number of bits transmitted by one character. */

typedef uint16_t LDD_SERIAL_TSize;     /*!< Type specifying the length of the data or buffer. */

typedef uint8_t LDD_SERIAL_TBaudMode;  /*!< Type specifying the baud mode. */

/*! Type specifying the parity. */
typedef enum {
  LDD_SERIAL_PARITY_UNDEF,             /*!< Undefined parity */
  LDD_SERIAL_PARITY_NONE,              /*!< Parity none */
  LDD_SERIAL_PARITY_ODD,               /*!< Parity odd */
  LDD_SERIAL_PARITY_EVEN,              /*!< Parity even */
  LDD_SERIAL_PARITY_MARK,              /*!< Parity mark */
  LDD_SERIAL_PARITY_SPACE              /*!< Parity space */
} LDD_SERIAL_TParity;

/*! Type specifying the stop bit length. */
typedef enum {
  LDD_SERIAL_STOP_BIT_LEN_UNDEF,       /*!< Undefined bit length */
  LDD_SERIAL_STOP_BIT_LEN_1,           /*!< 1 bit length */
  LDD_SERIAL_STOP_BIT_LEN_1_5,         /*!< 1.5 bit length */
  LDD_SERIAL_STOP_BIT_LEN_2            /*!< 2 bit length */
} LDD_SERIAL_TStopBitLen;

/*! Communication statistics */
typedef struct {
  uint32_t ReceivedChars;              /*!< Number of received characters */
  uint32_t SentChars;                  /*!< Number of transmitted characters */
  uint32_t ReceivedBreaks;             /*!< Number of received break characters */
  uint32_t ParityErrors;               /*!< Number of receiver parity errors */
  uint32_t FramingErrors;              /*!< Number of receiver framing errors */
  uint32_t OverrunErrors;              /*!< Number of receiver overrun errors */
  uint32_t NoiseErrors;                /*!< Number of receiver noise errors */
} LDD_SERIAL_TStats;

/*! Type specifying the loop mode operation. */
typedef enum {
  LOOPMODE_UNDEF,                      /*!< Undefined loop mode */
  LOOPMODE_NORMAL,                     /*!< Normal operation */
  LOOPMODE_AUTO_ECHO,                  /*!< Auto echo mode */
  LOOPMODE_LOCAL_LOOPBACK,             /*!< Local loopback mode */
  LOOPMODE_REMOTE_LOOPBACK             /*!< Remote loopback mode */
} LDD_SERIAL_TLoopMode;


/*
** ===================================================================
** ADC device types and constants
** ===================================================================
*/

#define LDD_ADC_CHANNEL_0_PIN                0x01u /*!< Channel 0 pin mask */
#define LDD_ADC_CHANNEL_1_PIN                0x02u /*!< Channel 1 pin mask */
#define LDD_ADC_CHANNEL_2_PIN                0x04u /*!< Channel 2 pin mask */
#define LDD_ADC_CHANNEL_3_PIN                0x08u /*!< Channel 3 pin mask */
#define LDD_ADC_CHANNEL_4_PIN                0x10u /*!< Channel 4 pin mask */
#define LDD_ADC_CHANNEL_5_PIN                0x20u /*!< Channel 5 pin mask */
#define LDD_ADC_CHANNEL_6_PIN                0x40u /*!< Channel 6 pin mask */
#define LDD_ADC_CHANNEL_7_PIN                0x80u /*!< Channel 7 pin mask */
#define LDD_ADC_CHANNEL_8_PIN                0x0100u /*!< Channel 8 pin mask */
#define LDD_ADC_CHANNEL_9_PIN                0x0200u /*!< Channel 9 pin mask */
#define LDD_ADC_CHANNEL_10_PIN                0x0400u /*!< Channel 10 pin mask */
#define LDD_ADC_CHANNEL_11_PIN                0x0800u /*!< Channel 11 pin mask */
#define LDD_ADC_CHANNEL_12_PIN                0x1000u /*!< Channel 12 pin mask */
#define LDD_ADC_CHANNEL_13_PIN                0x2000u /*!< Channel 13 pin mask */
#define LDD_ADC_CHANNEL_14_PIN                0x4000u /*!< Channel 14 pin mask */
#define LDD_ADC_CHANNEL_15_PIN                0x8000u /*!< Channel 15 pin mask */
#define LDD_ADC_CHANNEL_16_PIN                0x00010000u /*!< Channel 16 pin mask */
#define LDD_ADC_CHANNEL_17_PIN                0x00020000u /*!< Channel 17 pin mask */
#define LDD_ADC_CHANNEL_18_PIN                0x00040000u /*!< Channel 18 pin mask */
#define LDD_ADC_CHANNEL_19_PIN                0x00080000u /*!< Channel 19 pin mask */
#define LDD_ADC_CHANNEL_20_PIN                0x00100000u /*!< Channel 20 pin mask */
#define LDD_ADC_CHANNEL_21_PIN                0x00200000u /*!< Channel 21 pin mask */
#define LDD_ADC_CHANNEL_22_PIN                0x00400000u /*!< Channel 22 pin mask */
#define LDD_ADC_CHANNEL_23_PIN                0x00800000u /*!< Channel 23 pin mask */
#define LDD_ADC_CHANNEL_24_PIN                0x01000000u /*!< Channel 24 pin mask */
#define LDD_ADC_CHANNEL_25_PIN                0x02000000u /*!< Channel 25 pin mask */
#define LDD_ADC_CHANNEL_26_PIN                0x04000000u /*!< Channel 26 pin mask */
#define LDD_ADC_CHANNEL_27_PIN                0x08000000u /*!< Channel 27 pin mask */
#define LDD_ADC_CHANNEL_28_PIN                0x10000000u /*!< Channel 28 pin mask */
#define LDD_ADC_CHANNEL_29_PIN                0x20000000u /*!< Channel 29 pin mask */
#define LDD_ADC_CHANNEL_30_PIN                0x40000000u /*!< Channel 30 pin mask */
#define LDD_ADC_CHANNEL_31_PIN                0x80000000u /*!< Channel 31 pin mask */
#define LDD_ADC_CHANNEL_32_PIN                0x01u /*!< Channel 32 pin mask */
#define LDD_ADC_CHANNEL_33_PIN                0x02u /*!< Channel 33 pin mask */
#define LDD_ADC_CHANNEL_34_PIN                0x04u /*!< Channel 34 pin mask */
#define LDD_ADC_CHANNEL_35_PIN                0x08u /*!< Channel 35 pin mask */
#define LDD_ADC_CHANNEL_36_PIN                0x10u /*!< Channel 36 pin mask */
#define LDD_ADC_CHANNEL_37_PIN                0x20u /*!< Channel 37 pin mask */
#define LDD_ADC_CHANNEL_38_PIN                0x40u /*!< Channel 38 pin mask */
#define LDD_ADC_CHANNEL_39_PIN                0x80u /*!< Channel 39 pin mask */
#define LDD_ADC_CHANNEL_40_PIN                0x0100u /*!< Channel 40 pin mask */
#define LDD_ADC_CHANNEL_41_PIN                0x0200u /*!< Channel 41 pin mask */
#define LDD_ADC_CHANNEL_42_PIN                0x0400u /*!< Channel 42 pin mask */
#define LDD_ADC_CHANNEL_43_PIN                0x0800u /*!< Channel 43 pin mask */
#define LDD_ADC_CHANNEL_44_PIN                0x1000u /*!< Channel 44 pin mask */
#define LDD_ADC_CHANNEL_45_PIN                0x2000u /*!< Channel 45 pin mask */
#define LDD_ADC_CHANNEL_46_PIN                0x4000u /*!< Channel 46 pin mask */
#define LDD_ADC_CHANNEL_47_PIN                0x8000u /*!< Channel 47 pin mask */
#define LDD_ADC_CHANNEL_48_PIN                0x00010000u /*!< Channel 48 pin mask */
#define LDD_ADC_CHANNEL_49_PIN                0x00020000u /*!< Channel 49 pin mask */
#define LDD_ADC_CHANNEL_50_PIN                0x00040000u /*!< Channel 50 pin mask */
#define LDD_ADC_CHANNEL_51_PIN                0x00080000u /*!< Channel 51 pin mask */
#define LDD_ADC_CHANNEL_52_PIN                0x00100000u /*!< Channel 52 pin mask */
#define LDD_ADC_CHANNEL_53_PIN                0x00200000u /*!< Channel 53 pin mask */
#define LDD_ADC_CHANNEL_54_PIN                0x00400000u /*!< Channel 54 pin mask */
#define LDD_ADC_CHANNEL_55_PIN                0x00800000u /*!< Channel 55 pin mask */
#define LDD_ADC_CHANNEL_56_PIN                0x01000000u /*!< Channel 56 pin mask */
#define LDD_ADC_CHANNEL_57_PIN                0x02000000u /*!< Channel 57 pin mask */
#define LDD_ADC_CHANNEL_58_PIN                0x04000000u /*!< Channel 58 pin mask */
#define LDD_ADC_CHANNEL_59_PIN                0x08000000u /*!< Channel 59 pin mask */
#define LDD_ADC_CHANNEL_60_PIN                0x10000000u /*!< Channel 60 pin mask */
#define LDD_ADC_CHANNEL_61_PIN                0x20000000u /*!< Channel 61 pin mask */
#define LDD_ADC_CHANNEL_62_PIN                0x40000000u /*!< Channel 62 pin mask */
#define LDD_ADC_CHANNEL_63_PIN                0x80000000u /*!< Channel 63 pin mask */

#define LDD_ADC_TRIGGER_0_PIN                0x01u /*!< Trigger 0 pin mask */
#define LDD_ADC_TRIGGER_1_PIN                0x02u /*!< Trigger 1 pin mask */

#define LDD_ADC_LOW_VOLT_REF_PIN             0x01u /*!< Low voltage reference pin mask */
#define LDD_ADC_HIGH_VOLT_REF_PIN            0x02u /*!< High voltage reference pin mask */

#define LDD_ADC_ON_MEASUREMENT_COMPLETE 0x40u /*!< OnMeasurementComplete event mask */
#define LDD_ADC_ON_ERROR 0x80u         /*!< OnError event mask */

#define LDD_ADC_DMA_ERROR                   0x01u /*!< DMA error mask */

typedef uint32_t LDD_ADC_TErrorMask;   /*!< ADC error type */

/*! Structure pins for pin connection method */
typedef struct {
  uint32_t Channel0_31PinMask;         /*!< Channel pin mask for channels 0 through 31 */
  uint32_t Channel32_63PinMask;        /*!< Channel pin mask for channels 32 through 63 */
  uint16_t TriggerPinMask;             /*!< Trigger pin mask */
  uint8_t  VoltRefPinMask;             /*!< Voltage reference pin mask */
} LDD_ADC_TPinMask;

/*! Structure used to describing one sample */
typedef struct {
  uint8_t ChannelIdx;                  /*!< Channel index */
} LDD_ADC_TSample;

/*! Type specifying the ADC compare mode */
typedef enum {
  LDD_ADC_LESS_THAN                     = 0x00u, /*!< Compare true if the result is less than the Low compare value */
  LDD_ADC_GREATER_THAN_OR_EQUAL         = 0x01u, /*!< Compare true if the result is greater than or equal to Low compare value */
  LDD_ADC_INSIDE_RANGE_INCLUSIVE        = 0x02u, /*!< Compare true if the result is greater than or equal to Low compare value and the result is less than or equal to High compare value */
  LDD_ADC_INSIDE_RANGE_NOT_INCLUSIVE    = 0x03u, /*!< Compare true if the result is greater than Low compare value and the result is less than High compare value */
  LDD_ADC_OUTSIDE_RANGE_INCLUSIVE       = 0x04u, /*!< Compare true if the result is less than or equal to Low compare value or the result is greater than or equal to High compare value */
  LDD_ADC_OUTSIDE_RANGE_NOT_INCLUSIVE   = 0x05u /*!< Compare true if the result is less than Low compare value or the result is greater than High compare value */
} LDD_ADC_TCompareMode;

/*
** ===================================================================
** I2C device types and constants
** ===================================================================
*/

#define LDD_I2C_SDA_PIN                        0x01u /*!< SDA pin mask */
#define LDD_I2C_SCL_PIN                        0x02u /*!< SCL pin  mask */

#define LDD_I2C_ON_MASTER_BLOCK_SENT           0x0001u /*!<  OnMasterBlockSent event mask */
#define LDD_I2C_ON_MASTER_BLOCK_RECEIVED       0x0002u /*!<  OnMasterBlockReceived event mask */
#define LDD_I2C_ON_SLAVE_BLOCK_SENT            0x0004u /*!<  OnSlaveBlockSent event mask */
#define LDD_I2C_ON_SLAVE_BLOCK_RECEIVED        0x0008u /*!<  OnSlaveBlockReceived event mask */
#define LDD_I2C_ON_SLAVE_TX_REQUEST            0x0010u /*!<  OnSlaveTxRequest event mask */
#define LDD_I2C_ON_SLAVE_RX_REQUEST            0x0020u /*!<  OnSlaveRxRequest event mask */
#define LDD_I2C_ON_ERROR                       0x0040u /*!<  OnError event mask */
#define LDD_I2C_ON_SLAVE_SM_BUS_CALL_ADDR      0x0080u /*!<  OnSlaveSMBusCallAddr event mask */
#define LDD_I2C_ON_SLAVE_SM_BUS_ALERT_RESPONSE 0x0100u /*!<  OnSlaveSMBusAlertResponse event mask */
#define LDD_I2C_ON_SLAVE_GENERAL_CALL_ADDR     0x0200u /*!<  OnSlaveGeneralCallAddr event mask */
#define LDD_I2C_ON_MASTER_BYTE_RECEIVED        0x0400u /*!<  OnMasterByteReceived event mask */
#define LDD_I2C_ON_SLAVE_BYTE_RECEIVED         0x0800u /*!<  OnMasterByteReceived event mask */
#define LDD_I2C_ON_BUS_START_DETECTED          0x1000u /*!<  OnBusStartDetected event mask */
#define LDD_I2C_ON_BUS_STOP_DETECTED           0x2000u /*!<  OnBusStopDetected event mask */

#define LDD_I2C_SLAVE_TX_UNDERRUN              0x0001u /*!<  SlaveTxUnderrun error mask */
#define LDD_I2C_SLAVE_RX_OVERRUN               0x0002u /*!<  SlaveRxOverrun error mask */
#define LDD_I2C_ARBIT_LOST                     0x0004u /*!<  ArbitLost error mask */
#define LDD_I2C_MASTER_NACK                    0x0008u /*!<  MasterNACK error mask */
#define LDD_I2C_SCL_LOW_TIMEOUT                0x0010u /*!<  SCLLowTimeout error mask */
#define LDD_I2C_SDA_LOW_TIMEOUT                0x0020u /*!<  SDALowTimeout error mask */
#define LDD_I2C_SLAVE_NACK                     0x0040u /*!<  SlaveNACK error mask */

typedef uint16_t LDD_I2C_TSize;        /*!< Type specifying the length of the data or buffer. */
typedef uint16_t LDD_I2C_TAddr;        /*!< Type specifying the address variable */
typedef uint16_t LDD_I2C_TErrorMask;   /*!< Type specifying the error mask type. */
typedef bool LDD_I2C_TMode;            /*!< Type specifynng the Actual operating mode */

/*! Type specifying the address type  */
typedef enum {
  LDD_I2C_ADDRTYPE_7BITS,              /*!< 7 bits address */
  LDD_I2C_ADDRTYPE_10BITS,             /*!< 10 bits address */
  LDD_I2C_ADDRTYPE_GENERAL_CALL        /*!< General call address */
} LDD_I2C_TAddrType;

/*! Type specifying generate the stop condition  */
typedef enum {
  LDD_I2C_NO_SEND_STOP,                /*!< Do not send stop signal */
  LDD_I2C_SEND_STOP                    /*!< Send stop signal */
} LDD_I2C_TSendStop;

/*! Type specifying the I2C state of BUS. */
typedef enum {
  LDD_I2C_BUSY,                        /*!< The bus is busy */
  LDD_I2C_IDLE                         /*!< The bus is idle */
} LDD_I2C_TBusState;

/*! Type specifying the I2C byte acknowledge response. */
typedef enum {
  LDD_I2C_ACK_BYTE,                    /*!< Byte acknowledged */
  LDD_I2C_NACK_BYTE                    /*!< Byte not acknowledged */
} LDD_I2C_TAckType;

/*! Communication statistics */
typedef struct {
  uint32_t MasterSentChars;            /*!< Number of master transmitted characters. */
  uint32_t MasterReceivedChars;        /*!< Number of master received characters. */
  uint32_t MasterNacks;                /*!< Number of no acknowledges. */
  uint32_t ArbitLost;                  /*!< Number of lost the bus arbitration. */
  uint32_t SlaveSentChars;             /*!< Number of slave transmitted characters. */
  uint32_t SlaveReceivedChars;         /*!< Number of slave received characters. */
  uint32_t SlaveTxUnderrun;            /*!< Number of slave underrun. */
  uint32_t SlaveRxOverrun;             /*!< Number of slave overrun. */
  uint32_t SlaveGeneralCallAddr;       /*!< Number of a general call address. */
  uint32_t SlaveSmBusCallAddr;         /*!< Number of a SMBus call address. */
  uint32_t SlaveSmBusAlertResponse;    /*!< Number of slave SMBus alert response received. */
  uint32_t SCLLowTimeout;              /*!< Number of SCL low timeout occur. */
  uint32_t SDALowTimeout;              /*!< Number of SCL low timeout occur. */
} LDD_I2C_TStats;


/*
** ===================================================================
** SegLCD device types and constants
** ===================================================================
*/

#define LDD_SEGLCD_ON_FRAME_FREQUENCY         0x0001u /*!<  OnFrameFrequency event mask */
#define LDD_SEGLCD_ON_FAULT_DETECT_COMPLETE   0x0002u /*!<  OnFaultDetectComplete event mask */

typedef uint8_t LDD_SegLCD_TPinIndex;  /*!< Type specifying the segment LCD pin index variable */
typedef uint8_t LDD_SegLCD_TFrontplaneData; /*!< Type specifying the frontplane/backplane segment variable */
typedef uint8_t LDD_SegLCD_TFaultValue; /*!< Type specifying the frontplane/backplane segment variable */

/*! Types specifying the segment LCD blinking. */
typedef enum {
  LDD_SEGLCD_BLINK_OFF,                /*!< Disables display blinking */
  LDD_SEGLCD_BLINK_ALL,                /*!< Display blank during the blink period */
  LDD_SEGLCD_BLINK_ALL_ALTERNATE       /*!< Blinking between alternate backplane */
} LDD_SegLCD_TBlinking;

/*! Segment LCD blank state type. */
typedef enum {
  LDD_SEGLCD_BLANK_STATE,              /*!< Blank display mode */
  LDD_SEGLCD_NORMAL_STATE,             /*!< Normal display mode */
  LDD_SEGLCD_ALTERNATE_STATE           /*!< Alternate display mode */
} LDD_SegLCD_TSetBlank;

/*! Segment LCD pin type (frontplane/backplane) */
typedef enum {
  LDD_SEGLCD_BACKPLANE_PIN,            /*!< Backplane pin */
  LDD_SEGLCD_FRONTPLANE_PIN            /*!< Frontplane pin */
} LDD_SegLCD_TPinType;


/*
** ===================================================================
** GPIO device types and constants
** ===================================================================
*/

#define LDD_GPIO_PIN_0                0x01u /*!< Pin 0 inside the port */
#define LDD_GPIO_PIN_1                0x02u /*!< Pin 1 inside the port */
#define LDD_GPIO_PIN_2                0x04u /*!< Pin 2 inside the port */
#define LDD_GPIO_PIN_3                0x08u /*!< Pin 3 inside the port */
#define LDD_GPIO_PIN_4                0x10u /*!< Pin 4 inside the port */
#define LDD_GPIO_PIN_5                0x20u /*!< Pin 5 inside the port */
#define LDD_GPIO_PIN_6                0x40u /*!< Pin 6 inside the port */
#define LDD_GPIO_PIN_7                0x80u /*!< Pin 7 inside the port */
#define LDD_GPIO_PIN_8                0x0100u /*!< Pin 8 inside the port */
#define LDD_GPIO_PIN_9                0x0200u /*!< Pin 9 inside the port */
#define LDD_GPIO_PIN_10                0x0400u /*!< Pin 10 inside the port */
#define LDD_GPIO_PIN_11                0x0800u /*!< Pin 11 inside the port */
#define LDD_GPIO_PIN_12                0x1000u /*!< Pin 12 inside the port */
#define LDD_GPIO_PIN_13                0x2000u /*!< Pin 13 inside the port */
#define LDD_GPIO_PIN_14                0x4000u /*!< Pin 14 inside the port */
#define LDD_GPIO_PIN_15                0x8000u /*!< Pin 15 inside the port */
#define LDD_GPIO_PIN_16                0x00010000u /*!< Pin 16 inside the port */
#define LDD_GPIO_PIN_17                0x00020000u /*!< Pin 17 inside the port */
#define LDD_GPIO_PIN_18                0x00040000u /*!< Pin 18 inside the port */
#define LDD_GPIO_PIN_19                0x00080000u /*!< Pin 19 inside the port */
#define LDD_GPIO_PIN_20                0x00100000u /*!< Pin 20 inside the port */
#define LDD_GPIO_PIN_21                0x00200000u /*!< Pin 21 inside the port */
#define LDD_GPIO_PIN_22                0x00400000u /*!< Pin 22 inside the port */
#define LDD_GPIO_PIN_23                0x00800000u /*!< Pin 23 inside the port */
#define LDD_GPIO_PIN_24                0x01000000u /*!< Pin 24 inside the port */
#define LDD_GPIO_PIN_25                0x02000000u /*!< Pin 25 inside the port */
#define LDD_GPIO_PIN_26                0x04000000u /*!< Pin 26 inside the port */
#define LDD_GPIO_PIN_27                0x08000000u /*!< Pin 27 inside the port */
#define LDD_GPIO_PIN_28                0x10000000u /*!< Pin 28 inside the port */
#define LDD_GPIO_PIN_29                0x20000000u /*!< Pin 29 inside the port */
#define LDD_GPIO_PIN_30                0x40000000u /*!< Pin 30 inside the port */
#define LDD_GPIO_PIN_31                0x80000000u /*!< Pin 31 inside the port */

#define LDD_GPIO_ON_PORT_EVENT 0x01u   /*!< OnPortEvent event mask */

typedef uint32_t LDD_GPIO_TBitField;   /*!< Abstract type specifying the bit field within the port. */

/*! Defines condition when event is invoked. */
typedef enum {
  LDD_GPIO_DISABLED = 0x00u,           /*!< Event doesn't invoke */
  LDD_GPIO_LOW      = 0x00080000u,     /*!< Event when logic zero */
  LDD_GPIO_HIGH     = 0x000C0000u,     /*!< Event when logic one */
  LDD_GPIO_RISING   = 0x00090000u,     /*!< Event on rising edge */
  LDD_GPIO_FALLING  = 0x000A0000u,     /*!< Event on falling edge */
  LDD_GPIO_BOTH     = 0x000B0000u      /*!< Event on rising and falling edge */
} LDD_GPIO_TEventCondition;            /*!< Defines condition when event is invoked. */

#define LDD_GPIO_EVENT_CONDITIONS_MASK 0x000F0000u

/*
** ===================================================================
** BITSIO device types and constants
** ===================================================================
*/
#define LDD_BITSIO_PIN_0   0x01U       /*!< Pin 0 inside pin list of component */
#define LDD_BITSIO_PIN_1   0x02U       /*!< Pin 1 inside pin list of component */
#define LDD_BITSIO_PIN_2   0x04U       /*!< Pin 2 inside pin list of component */
#define LDD_BITSIO_PIN_3   0x08U       /*!< Pin 3 inside pin list of component */
#define LDD_BITSIO_PIN_4   0x10U       /*!< Pin 4 inside pin list of component */
#define LDD_BITSIO_PIN_5   0x20U       /*!< Pin 5 inside pin list of component */
#define LDD_BITSIO_PIN_6   0x40U       /*!< Pin 6 inside pin list of component */
#define LDD_BITSIO_PIN_7   0x80U       /*!< Pin 7 inside pin list of component */
#define LDD_BITSIO_PIN_8   0x0100U     /*!< Pin 8 inside pin list of component */
#define LDD_BITSIO_PIN_9   0x0200U     /*!< Pin 9 inside pin list of component */
#define LDD_BITSIO_PIN_10   0x0400U    /*!< Pin 10 inside pin list of component */
#define LDD_BITSIO_PIN_11   0x0800U    /*!< Pin 11 inside pin list of component */
#define LDD_BITSIO_PIN_12   0x1000U    /*!< Pin 12 inside pin list of component */
#define LDD_BITSIO_PIN_13   0x2000U    /*!< Pin 13 inside pin list of component */
#define LDD_BITSIO_PIN_14   0x4000U    /*!< Pin 14 inside pin list of component */
#define LDD_BITSIO_PIN_15   0x8000U    /*!< Pin 15 inside pin list of component */
#define LDD_BITSIO_PIN_16   0x00010000U /*!< Pin 16 inside pin list of component */
#define LDD_BITSIO_PIN_17   0x00020000U /*!< Pin 17 inside pin list of component */
#define LDD_BITSIO_PIN_18   0x00040000U /*!< Pin 18 inside pin list of component */
#define LDD_BITSIO_PIN_19   0x00080000U /*!< Pin 19 inside pin list of component */
#define LDD_BITSIO_PIN_20   0x00100000U /*!< Pin 20 inside pin list of component */
#define LDD_BITSIO_PIN_21   0x00200000U /*!< Pin 21 inside pin list of component */
#define LDD_BITSIO_PIN_22   0x00400000U /*!< Pin 22 inside pin list of component */
#define LDD_BITSIO_PIN_23   0x00800000U /*!< Pin 23 inside pin list of component */
#define LDD_BITSIO_PIN_24   0x01000000U /*!< Pin 24 inside pin list of component */
#define LDD_BITSIO_PIN_25   0x02000000U /*!< Pin 25 inside pin list of component */
#define LDD_BITSIO_PIN_26   0x04000000U /*!< Pin 26 inside pin list of component */
#define LDD_BITSIO_PIN_27   0x08000000U /*!< Pin 27 inside pin list of component */
#define LDD_BITSIO_PIN_28   0x10000000U /*!< Pin 28 inside pin list of component */
#define LDD_BITSIO_PIN_29   0x20000000U /*!< Pin 29 inside pin list of component */
#define LDD_BITSIO_PIN_30   0x40000000U /*!< Pin 30 inside pin list of component */
#define LDD_BITSIO_PIN_31   0x80000000U /*!< Pin 31 inside pin list of component */

/*
** ===================================================================
** Ethernet device types and constants
** ===================================================================
*/

#define LDD_ETH_MDC_PIN     0x01u      /*!< MDC pin mask */
#define LDD_ETH_MDIO_PIN    0x02u      /*!< MDIO pin mask */
#define LDD_ETH_COL_PIN     0x04u      /*!< COL pin mask */
#define LDD_ETH_CRS_PIN     0x08u      /*!< CRS pin mask */
#define LDD_ETH_TXCLK_PIN   0x10u      /*!< TXCLK pin mask */
#define LDD_ETH_TXD0_PIN    0x20u      /*!< TXD0 pin mask */
#define LDD_ETH_TXD1_PIN    0x40u      /*!< TXD1 pin mask */
#define LDD_ETH_TXD2_PIN    0x80u      /*!< TXD2 pin mask */
#define LDD_ETH_TXD3_PIN    0x0100u    /*!< TXD3 pin mask */
#define LDD_ETH_TXEN_PIN    0x0200u    /*!< TXEN pin mask */
#define LDD_ETH_TXER_PIN    0x0400u    /*!< TXER pin mask */
#define LDD_ETH_RXCLK_PIN   0x0800u    /*!< RXCLK pin mask */
#define LDD_ETH_RXDV_PIN    0x1000u    /*!< RXDV pin mask */
#define LDD_ETH_RXD0_PIN    0x2000u    /*!< RXD0 pin mask */
#define LDD_ETH_RXD1_PIN    0x4000u    /*!< RXD1 pin mask */
#define LDD_ETH_RXD2_PIN    0x8000u    /*!< RXD2 pin mask */
#define LDD_ETH_RXD3_PIN    0x00010000u /*!< RXD3 pin mask */
#define LDD_ETH_RXER_PIN    0x00020000u /*!< RXER pin mask */

#define LDD_ETH_ON_FRAME_TRANSMITTED              0x01u /*!< OnFrameTransmitted event mask */
#define LDD_ETH_ON_FRAME_TRANSMITTED_TIMESTAMPED  0x02u /*!< OnFrameTransmittedTimestamped event mask */
#define LDD_ETH_ON_FRAME_RECEIVED                 0x04u /*!< OnFrameReceived event mask */
#define LDD_ETH_ON_FRAME_RECEIVED_TIMESTAMPED     0x08u /*!< OnFrameReceivedTimestamped event mask */
#define LDD_ETH_ON_MII_FINISHED                   0x10u /*!< OnMIIFinished event mask */
#define LDD_ETH_ON_FATAL_ERROR                    0x20u /*!< OnFatalError event mask */
#define LDD_ETH_ON_WAKE_UP                        0x40u /*!< OnWakeUp event mask */

typedef uint8_t LDD_ETH_TMACAddress[6]; /*!< Ethernet MAC address */

/*! Ethernet duplex mode */
typedef enum {
  LDD_ETH_FULL_DUPLEX,                 /*!< Full duplex mode */
  LDD_ETH_HALF_DUPLEX                  /*!< Half duplex mode */
} LDD_ETH_TDuplexMode;

/*! Ethernet address filter mode options */
typedef enum {
  LDD_ETH_PROMISC,                     /*!< Promiscuous mode */
  LDD_ETH_REJECT_BC,                   /*!< Reject broadcast frames */
  LDD_ETH_ACCEPT_BC                    /*!< Accept broadcast frames */
} LDD_ETH_TFilterMode;

/*! Ethernet sleep mode options */
typedef enum {
  LDD_ETH_ENABLED,                     /*!< Sleep mode enabled */
  LDD_ETH_ENABLED_WITH_WAKEUP,         /*!< Sleep mode enabled, waiting for wake-up */
  LDD_ETH_DISABLED                     /*!< Sleep mode disabled */
} LDD_ETH_TSleepMode;

/*! Ethernet frame buffer (fragment) descriptor */
typedef struct {
  uint8_t  *DataPtr;                   /*!< Pointer to buffer data */
  uint16_t Size;                       /*!< Buffer data size */
} LDD_ETH_TBufferDesc;

typedef LDD_ETH_TBufferDesc* LDD_ETH_TBufferDescPtr; /*!< Frame buffer descriptor pointer type */

/*! Ethernet communication statistics */
typedef struct {
  uint32_t TxRMONDropEvents;           /*!< Count of frames not counted correctly */
  uint32_t TxRMONOctets;               /*!< Octet count for frames transmitted without error */
  uint32_t TxRMONPackets;              /*!< Transmitted packet count */
  uint32_t TxRMONBroadcastPackets;     /*!< Transmitted broadcast packets */
  uint32_t TxRMONMulticastPackets;     /*!< Transmitted multicast packets */
  uint32_t TxRMONCRCAlignErrors;       /*!< Transmitted packets with CRC or alignment error */
  uint32_t TxRMONUndersizePackets;     /*!< Transmitted packets smaller than 64 bytes with good CRC */
  uint32_t TxRMONOversizePackets;      /*!< Transmitted packets greater than max. frame length with good CRC */
  uint32_t TxRMONFragments;            /*!< Transmitted packets smaller than 64 bytes with bad CRC */
  uint32_t TxRMONJabbers;              /*!< Transmitted packets greater than max. frame length with bad CRC */
  uint32_t TxRMONCollisions;           /*!< Transmit collision count */
  uint32_t TxRMONPackets64Octets;      /*!< Transmitted 64 byte packets */
  uint32_t TxRMONPackets65To127Octets; /*!< Transmitted 65 to 127 byte packets */
  uint32_t TxRMONPackets128To255Octets; /*!< Transmitted 128 to 255 byte packets */
  uint32_t TxRMONPackets256To511Octets; /*!< Transmitted 256 to 511 byte packets */
  uint32_t TxRMONPackets512To1023Octets; /*!< Transmitted 512 to 1023 byte packets */
  uint32_t TxRMONPackets1024To2047Octets; /*!< Transmitted 1024 to 2047 byte packets */
  uint32_t TxRMONPacketsGreaterThan2048Octets; /*!< Transmitted packets greater than 2048 byte */
  uint32_t TxIEEEDrop;                 /*!< Count of frames not counted correctly */
  uint32_t TxIEEEFrameOK;              /*!< Frames transmitted OK */
  uint32_t TxIEEESingleCollision;      /*!< Frames transmitted with single collision */
  uint32_t TxIEEEMultipleCollisions;   /*!< Frames transmitted with multiple collisions */
  uint32_t TxIEEEDeferralDelay;        /*!< Frames transmitted after deferral delay */
  uint32_t TxIEEELateCollision;        /*!< Frames transmitted with late collision */
  uint32_t TxIEEEExcessiveCollision;   /*!< Frames transmitted with excessive collisions */
  uint32_t TxIEEEFIFOUnderrun;         /*!< Frames transmitted with transmit FIFO underrun */
  uint32_t TxIEEECarrierSenseError;    /*!< Frames transmitted with carrier sense error */
  uint32_t TxIEEESQEError;             /*!< Frames transmitted with SQE error */
  uint32_t TxIEEEPauseFrame;           /*!< Flow control pause frames transmitted */
  uint32_t TxIEEEOctetsOK;             /*!< Octet count for frames transmitted without error */
  uint32_t RxRMONDropEvents;           /*!< Count of frames not counted correctly */
  uint32_t RxRMONOctets;               /*!< Octet count for frames recieved without error */
  uint32_t RxRMONPackets;              /*!< Received packet count */
  uint32_t RxRMONBroadcastPackets;     /*!< Received broadcast packets */
  uint32_t RxRMONMulticastPackets;     /*!< Received multicast packets */
  uint32_t RxRMONCRCAlignErrors;       /*!< Received packets with CRC or alignment error */
  uint32_t RxRMONUndersizePackets;     /*!< Received packets smaller than 64 bytes with good CRC */
  uint32_t RxRMONOversizePackets;      /*!< Received packets greater than max. frame length with good CRC */
  uint32_t RxRMONFragments;            /*!< Received packets smaller than 64 bytes with bad CRC */
  uint32_t RxRMONJabbers;              /*!< Received packets greater than max. frame length with bad CRC */
  uint32_t RxRMONPackets64Octets;      /*!< Received 64 byte packets */
  uint32_t RxRMONPackets65To127Octets; /*!< Received 65 to 127 byte packets */
  uint32_t RxRMONPackets128To255Octets; /*!< Received 128 to 255 byte packets */
  uint32_t RxRMONPackets256To511Octets; /*!< Received 256 to 511 byte packets */
  uint32_t RxRMONPackets512To1023Octets; /*!< Received 512 to 1023 byte packets */
  uint32_t RxRMONPackets1024To2047Octets; /*!< Received 1024 to 2047 byte packets */
  uint32_t RxRMONPacketsGreaterThan2048Octets; /*!< Received packets greater than 2048 byte */
  uint32_t RxIEEEDrop;                 /*!< Count of frames not counted correctly */
  uint32_t RxIEEEFrameOK;              /*!< Frames received OK */
  uint32_t RxIEEECRCError;             /*!< Frames received with CRC error */
  uint32_t RxIEEEAlignmentError;       /*!< Frames received with alignment error */
  uint32_t RxIEEEFIFOOverflow;         /*!< Receive FIFO overflow count */
  uint32_t RxIEEEPauseFrame;           /*!< Flow control pause frames received */
  uint32_t RxIEEEOctetsOK;             /*!< Octet count for frames received without error */
} LDD_ETH_TStats;

/*
** ===================================================================
** FlexCAN device types and constants
** ===================================================================
*/

typedef uint8_t LDD_CAN_TMBIndex;      /*!< CAN message buffer index */
typedef uint32_t LDD_CAN_TAccMask;     /*!< Type specifying the acceptance mask variable. */
typedef uint32_t LDD_CAN_TMessageID;   /*!< Type specifying the ID mask variable. */
typedef uint8_t LDD_CAN_TErrorCounter; /*!< Type specifying the error counter variable. */
typedef uint32_t LDD_CAN_TErrorMask;   /*!< Type specifying the error mask variable. */
typedef uint16_t LDD_CAN_TBufferMask;  /*!< Type specifying the message buffer mask variable. */
#define LDD_CAN_RX_PIN            0x01U /*!< Rx pin mask */
#define LDD_CAN_TX_PIN            0x02U /*!< Tx pin mask */

#define LDD_CAN_ON_FULL_RXBUFFER  0x01U /*!< OnFullRxBuffer event mask */
#define LDD_CAN_ON_FREE_TXBUFFER  0x02U /*!< OnFreeTxBuffer event mask */
#define LDD_CAN_ON_BUSOFF         0x04U /*!< OnBusOff event mask */
#define LDD_CAN_ON_TXWARNING      0x08U /*!< OnTransmitterWarning event mask */
#define LDD_CAN_ON_RXWARNING      0x10U /*!< OnReceiverWarning event mask */
#define LDD_CAN_ON_ERROR          0x20U /*!< OnError event mask */
#define LDD_CAN_ON_WAKEUP         0x40U /*!< OnWakeUp event mask */

#define LDD_CAN_BIT0_ERROR        0x4000UL /*!< Bit0 error detect error mask */
#define LDD_CAN_BIT1_ERROR        0x8000UL /*!< Bit1 error detect error mask */
#define LDD_CAN_ACK_ERROR         0x2000UL /*!< Acknowledge error detect error mask */
#define LDD_CAN_CRC_ERROR         0x1000UL /*!< Cyclic redundancy check error detect error mask */
#define LDD_CAN_FORM_ERROR        0x0800UL /*!< Message form error detect error mask */
#define LDD_CAN_STUFFING_ERROR    0x0400UL /*!< Bit stuff error detect error mask */

#define LDD_CAN_MESSAGE_ID_EXT    0x80000000UL /*!< Value specifying extended Mask, ID */

/*! Type specifying the CAN frame type. */
typedef enum {
  LDD_CAN_MB_RX_NOT_ACTIVE = 0x00U,
  LDD_CAN_MB_RX_FULL       = 0x02U,
  LDD_CAN_MB_RX_EMPTY      = 0x04U,
  LDD_CAN_MB_RX_OVERRUN    = 0x06U,
  LDD_CAN_MB_RX_BUSY       = 0x01U,
  LDD_CAN_MB_RX_RANSWER    = 0x0AU
} LDD_CAN_TRxBufferState;

/*! Type specifying the CAN frame type. */
typedef enum {
  LDD_CAN_DATA_FRAME,                  /*!< Data frame type received or transmitted */
  LDD_CAN_REMOTE_FRAME,                /*!< Remote frame type  */
  LDD_CAN_RESPONSE_FRAME               /*!< Response frame type - Tx buffer send data after receiving remote frame with the same ID */
} LDD_CAN_TFrameType;

/*! Type specifying the CAN communication statistics. */
typedef struct {
  uint32_t TxFrames;                   /*!< Transmitted frame counter */
  uint32_t TxWarnings;                 /*!< Transmission warning counter */
  uint32_t RxFrames;                   /*!< Received frame counter */
  uint32_t RxWarnings;                 /*!< Reception warning counter */
  uint32_t BusOffs;                    /*!< Bus off counter */
  uint32_t Wakeups;                    /*!< Wakeup counter */
  uint32_t Bit0Errors;                 /*!< Bit0 error counter */
  uint32_t Bit1Errors;                 /*!< Bit1 error counter */
  uint32_t AckErrors;                  /*!< ACK error counter */
  uint32_t CrcErrors;                  /*!< CRC error counter */
  uint32_t FormErrors;                 /*!< Message form error counter */
  uint32_t BitStuffErrors;             /*!< Bit stuff error counter */
  uint32_t Errors;                     /*!< Error counter */
} LDD_CAN_TStats;

/*! Type specifying the CAN frame features. */
typedef struct {
  LDD_CAN_TMessageID MessageID;        /*!< Message ID */
  LDD_CAN_TFrameType FrameType;        /*!< Type of the frame DATA/REMOTE */
  uint8_t *Data;                       /*!< Message data buffer */
  uint8_t  Length;                     /*!< Message length */
  uint16_t TimeStamp;                  /*!< Message time stamp */
  uint8_t  LocPriority;                /*!< Local Priority Tx Buffers */
} LDD_CAN_TFrame;

/*
** ===================================================================
** USB device types and constants
** ===================================================================
*/

/* Events' masks */
#define LDD_USB_ON_DEVICE_RESET            0x00000001u /*!< OnDeviceReset event mask */
#define LDD_USB_ON_DEVICE_SPEED_DETECT     0x00000002u /*!< OnDeviceSpeedDetect event mask */
#define LDD_USB_ON_DEVICE_SUSPEND          0x00000004u /*!< OnDeviceSuspend event mask */
#define LDD_USB_ON_DEVICE_RESUME           0x00000008u /*!< OnDeviceResume event mask */
#define LDD_USB_ON_DEVICE_SETUP_PACKET     0x00000010u /*!< OnDeviceSetupPacket event mask */
#define LDD_USB_ON_DEVICE_SOF              0x00000020u /*!< OnDeviceSof event mask */
#define LDD_USB_ON_DEVICE_1MS_TIMER        0x00000040u /*!< OnDevice1msTimer event mask */
#define LDD_USB_ON_DEVICE_1_MS_TIMER       0x00000040u /*!< OnDevice1msTimer event mask */
#define LDD_USB_ON_DEVICE_ERROR            0x00000080u /*!< OnDeviceError event mask */
#define LDD_USB_ON_HOST_DEVICE_DEATTACH    0x00000100u /*!< OnHostDeviceAttach event mask */
#define LDD_USB_ON_HOST_RESET_RECOVERY     0x00000200u /*!< OnHostResetRecovery event mask */
#define LDD_USB_ON_HOST_RESUME_RECOVERY    0x00000400u /*!< OnHostResumeRecovery event mask */
#define LDD_USB_ON_HOST_1MS_TIMER          0x00000800u /*!< 1 ms timer event mask */
#define LDD_USB_ON_HOST_1_MS_TIMER         0x00000800u /*!< 1 ms timer event mask */
#define LDD_USB_ON_HOST_ERROR              0x00001000u /*!< OnHostError event mask */
#define LDD_USB_ON_OTG_DEVICE              0x00002000u /*!< OnOtgDevice event mask */
#define LDD_USB_ON_OTG_HOST                0x00004000u /*!< OnOtgHost event mask */
#define LDD_USB_ON_OTG_STATE_CHANGE        0x00008000u /*!< OnOtgStageChange event mask */
#define LDD_USB_ON_SIGNAL_CHANGE           0x00010000u /*!< OnSignalChange event mask */

/* Data pins' masks */
#define LDD_USB_DP_PIN                     0x00000001u /*!< Data+ pin mask */
#define LDD_USB_DM_PIN                     0x00000002u /*!< Data- pin mask */

/* Pullup/pulldown pin masks */
#define LDD_USB_DP_PU_PIN                  0x00000004u /*!< Data+ pull-up pin mask */
#define LDD_USB_DM_PU_PIN                  0x00000008u /*!< Data- pull-up pin mask */
#define LDD_USB_DP_PD_PIN                  0x00000010u /*!< Data+ pull-down pin mask */
#define LDD_USB_DM_PD_PIN                  0x00000020u /*!< Data- pull-down pin mask */

/* VBUS pins' mask */
#define LDD_USB_DEVICE_VBUS_DETECT_PIN     0x00000040u /*!< VBUS detect pin mask */
#define LDD_USB_HOST_VBUS_ENABLE_PIN       0x00000080u /*!< VBUS enable pin mask */
#define LDD_USB_HOST_VBUS_OVERCURRENT_PIN  0x00000100u /*!< VBUS overcurrent pin mask */

/* OTG pins' masks */
#define LDD_USB_OTG_ID_PIN                 0x00000200u /*!< ID pin mask */
#define LDD_USB_OTG_VBUS_VALID_PIN         0x00000400u /*!< VBUS valid pin mask */
#define LDD_USB_OTG_SESSION_VALID_PIN      0x00000800u /*!< SESSION valid pin mask */
#define LDD_USB_OTG_B_SESSION_END_PIN      0x00004000u /*!< B SESSION end pin mask */
#define LDD_USB_OTG_VBUS_ENABLE_PIN        0x00008000u /*!< VBUS drive pin mask */
#define LDD_USB_OTG_VBUS_CHARGE_PIN        0x00010000u /*!< VBUS charge pin mask */
#define LDD_USB_OTG_VBUS_DISCHARGE_PIN     0x00020000u /*!< VBUS discharge pin mask */

/* ULPI pins' masks */
#define LDD_USB_ULPI_CLK_PIN               0x00080000u /*!< ULPI_CLK pin mask */
#define LDD_USB_ULPI_DIR_PIN               0x00100000u /*!< ULPI_DIR pin mask */
#define LDD_USB_ULPI_NXT_PIN               0x00200000u /*!< ULPI_NXT pin mask */
#define LDD_USB_ULPI_STP_PIN               0x00400000u /*!< ULPI_STOP pin mask */
#define LDD_USB_ULPI_DATA_0_PIN            0x00800000u /*!< ULPI_DATA_0 pin mask */
#define LDD_USB_ULPI_DATA_1_PIN            0x01000000u /*!< ULPI_DATA_1 pin mask */
#define LDD_USB_ULPI_DATA_2_PIN            0x02000000u /*!< ULPI_DATA_2 pin mask */
#define LDD_USB_ULPI_DATA_3_PIN            0x04000000u /*!< ULPI_DATA_3 pin mask */
#define LDD_USB_ULPI_DATA_4_PIN            0x08000000u /*!< ULPI_DATA_4 pin mask */
#define LDD_USB_ULPI_DATA_5_PIN            0x10000000u /*!< ULPI_DATA_5 pin mask */
#define LDD_USB_ULPI_DATA_6_PIN            0x20000000u /*!< ULPI_DATA_6 pin mask */
#define LDD_USB_ULPI_DATA_7_PIN            0x40000000u /*!< ULPI_DATA_7 pin mask */

/* Alternate clock pin*/
#define LDD_USB_CLKIN_PIN                  0x80000000u /*!< Alternate clock pin mask */
#define LDD_USB_ALT_CLK_PIN                0x80000000u /*!< Alternate clock pin mask */

/* DeviceSetUsbStatus()/DeviceGetUsbStatus methods Cmd/CmdStatusPtr param. values */
#define LDD_USB_CMD_GET_EP_STATUS              0x00u /*!< Get endpoint status command ID */
#define LDD_USB_CMD_SET_EP_HALT_FATURE         0x01u /*!< Set endpoint HALT feature command ID */
#define LDD_USB_CMD_CLR_EP_HALT_FATURE         0x02u /*!< Clear endpoint HALT feature command ID */

#define LDD_USB_CMD_EP_STATUS_HALT_MASK        0x01u /*!< Endpoint halt status mask */


/* DeviceSetUsbStatus()/DeviceGetUsbStatus methods Recipient param. values */
/* (see USB 2.0, chapter 9.3.4 wIndex description)*/
#define LDD_USB_ID_EP0_OUT                     0x00u /*!< EP0 OUT component ID */
#define LDD_USB_ID_EP0_IN                      0x80u /*!< EP0 IN component ID */
#define LDD_USB_ID_EP1_OUT                     0x01u /*!< EP1 OUT component ID */
#define LDD_USB_ID_EP1_IN                      0x81u /*!< EP1 IN component ID */
#define LDD_USB_ID_EP2_OUT                     0x02u /*!< EP2 OUT component ID */
#define LDD_USB_ID_EP2_IN                      0x82u /*!< EP2 IN component ID */
#define LDD_USB_ID_EP3_OUT                     0x03u /*!< EP3 OUT component ID */
#define LDD_USB_ID_EP3_IN                      0x83u /*!< EP3 IN component ID */
#define LDD_USB_ID_EP4_OUT                     0x04u /*!< EP4 OUT component ID */
#define LDD_USB_ID_EP4_IN                      0x84u /*!< EP4 IN component ID */
#define LDD_USB_ID_EP5_OUT                     0x05u /*!< EP5 OUT component ID */
#define LDD_USB_ID_EP5_IN                      0x85u /*!< EP5 IN component ID */
#define LDD_USB_ID_EP6_OUT                     0x06u /*!< EP6 OUT component ID */
#define LDD_USB_ID_EP6_IN                      0x86u /*!< EP6 IN component ID */
#define LDD_USB_ID_EP7_OUT                     0x07u /*!< EP7 OUT component ID */
#define LDD_USB_ID_EP7_IN                      0x87u /*!< EP7 IN component ID */
#define LDD_USB_ID_EP8_OUT                     0x08u /*!< EP8 OUT component ID */
#define LDD_USB_ID_EP8_IN                      0x88u /*!< EP8 IN component ID */
#define LDD_USB_ID_EP9_OUT                     0x09u /*!< EP9 OUT component ID */
#define LDD_USB_ID_EP9_IN                      0x89u /*!< EP9 IN component ID */
#define LDD_USB_ID_EP10_OUT                    0x0Au /*!< EP10 OUT component ID */
#define LDD_USB_ID_EP10_IN                     0x8Au /*!< EP10 IN component ID */
#define LDD_USB_ID_EP11_OUT                    0x0Bu /*!< EP11 OUT component ID */
#define LDD_USB_ID_EP11_IN                     0x8Bu /*!< EP11 IN component ID */
#define LDD_USB_ID_EP12_OUT                    0x0Cu /*!< EP12 OUT component ID */
#define LDD_USB_ID_EP12_IN                     0x8Cu /*!< EP12 IN component ID */
#define LDD_USB_ID_EP13_OUT                    0x0Du /*!< EP13 OUT component ID */
#define LDD_USB_ID_EP13_IN                     0x8Du /*!< EP13 IN component ID */
#define LDD_USB_ID_EP14_OUT                    0x0Eu /*!< EP14 OUT component ID */
#define LDD_USB_ID_EP14_IN                     0x8Eu /*!< EP14 IN component ID */
#define LDD_USB_ID_EP15_OUT                    0x0Fu /*!< EP15 OUT component ID */
#define LDD_USB_ID_EP15_IN                     0x8Fu /*!< EP15 IN component ID */
#define LDD_USB_ID_EP_MASK                     0x8Fu /*!< EP15 IN component ID */

/* Token PID */
#define LDD_USB_PID_OUT                        0x01u /*!< OUT */
#define LDD_USB_PID_IN                         0x09u /*!< IN */
#define LDD_USB_PID_SOF                        0x05u /*!< SOF */
#define LDD_USB_PID_SETUP                      0x0Du /*!< SETUP */
/* Data PID */
#define LDD_USB_PID_DATA0                      0x03u /*!< DATA0 */
#define LDD_USB_PID_DATA1                      0x0Bu /*!< DATA1 */
#define LDD_USB_PID_DATA2                      0x07u /*!< DATA2 */
#define LDD_USB_PID_MDATA                      0x0Fu /*!< MDATA */
/* Handshake PID */
#define LDD_USB_PID_ACK                        0x02u /*!< ACK */
#define LDD_USB_PID_NACK                       0x0Au /*!< NACK */
#define LDD_USB_PID_STALL                      0x0Eu /*!< STALL */
#define LDD_USB_PID_NYET                       0x06u /*!< NYET */
/* Special PID */
#define LDD_USB_PID_PRE                        0x0Cu /*!< PRE */
#define LDD_USB_PID_ERR                        0x0Cu /*!< ERR */
#define LDD_USB_PID_SPLIT                      0x08u /*!< SPLIT */
#define LDD_USB_PID_PING                       0x04u /*!< PING */

/* Data direction */
#define LDD_USB_DIR_OUT                        0x00u /*!< Recipient is Device */
#define LDD_USB_DIR_IN                         0x80u /*!< Recipient is Host */
#define LDD_USB_DIR_MASK                       0x80u /*!< Bit mask for data transfer direction */

/* Flags used in the TD.Head.Flags variable */

/* The following flag can be used to force zero-length termination(ZLT) of the transfer.
   Note: ZLT can be set for all transfer during the initialization of the endpoint.
*/
#define LDD_USB_DEVICE_TRANSFER_FLAG_ZLT       0x01u

/* If the TRANSFER_FLAG_EXT_PARAM is defined all variables of the TD are used
  and TD must NOT be freed until transfer is done or is cancelled
  (TransferState != LDD_USB_TRANSFER_PENDING)
  If not defined only the Head member of TD is used and TD can be freed after
  Send/Recv() method returns.
*/
#define LDD_USB_DEVICE_TRANSFER_FLAG_EXT_PARAM 0x02u


#define ERR_COMPONET_SPECIFIC 0x100u

/* Device mode USB specific error codes */
#define ERR_USB_DEVICE_DISABLED                (ERR_COMPONET_SPECIFIC + 0x00u) /*!< Device mode is disabled (by the user or by the clock configuration) */
#define ERR_USB_DEVICE_DISABLED_BY_OTG         (ERR_COMPONET_SPECIFIC + 0x01u) /*!< Device mode is disabled by the OTG driver */
#define ERR_USB_DEVICE_VBUS_OFF                (ERR_COMPONET_SPECIFIC + 0x02u) /*!< No VBUS is detected */
#define ERR_USB_DEVICE_VBUS_ON                 (ERR_COMPONET_SPECIFIC + 0x03u) /*!< VBUS is detected */
#define ERR_USB_DEVICE_ENABLED                 (ERR_COMPONET_SPECIFIC + 0x04u) /*!< Device is enabled */
#define ERR_USB_DEVICE_SUSPENDED               (ERR_COMPONET_SPECIFIC + 0x05u) /*!< Device is suspended */
#define ERR_USB_DEVICE_SUSPENDED_RESUME_READY  (ERR_COMPONET_SPECIFIC + 0x06u) /*!< Device is suspended and ready to generate resume signaling */
#define ERR_USB_DEVICE_RESUME_PENDING          (ERR_COMPONET_SPECIFIC + 0x07u) /*!< Device generates resume signaling */

/* Host mode USB specific error codes */
#define ERR_USB_HOST_DISABLED                  (ERR_COMPONET_SPECIFIC + 0x00u) /*!< Host mode is disabled (by the user or by the clock configuration) */
#define ERR_USB_HOST_DISABLED_BY_OTG           (ERR_COMPONET_SPECIFIC + 0x01u) /*!< Host mode is disabled by the OTG driver */
#define ERR_USB_HOST_PORT_POWERED_OFF          (ERR_COMPONET_SPECIFIC + 0x02u) /*!< Port is power off */
#define ERR_USB_HOST_PORT_DISCONNECTED         (ERR_COMPONET_SPECIFIC + 0x03u) /*!< Port is power on */
#define ERR_USB_HOST_PORT_DISABLED             (ERR_COMPONET_SPECIFIC + 0x04u) /*!< Device is connected to the port */
#define ERR_USB_HOST_PORT_RESETING             (ERR_COMPONET_SPECIFIC + 0x05u) /*!< Port generates reset signaling */
#define ERR_USB_HOST_PORT_RESET_RECOVERING     (ERR_COMPONET_SPECIFIC + 0x06u) /*!< Port waits 10ms for reset recovery */
#define ERR_USB_HOST_PORT_ENABLED              (ERR_COMPONET_SPECIFIC + 0x07u) /*!< PortDevice is connected, reset and ready to use */
#define ERR_USB_HOST_PORT_SUSPENDED            (ERR_COMPONET_SPECIFIC + 0x08u) /*!< Port is suspended */
#define ERR_USB_HOST_PORT_RESUME_READY         (ERR_COMPONET_SPECIFIC + 0x09u) /*!< Port can generate resume signaling */
#define ERR_USB_HOST_PORT_RESUMING             (ERR_COMPONET_SPECIFIC + 0x0Au) /*!< Port generates resume signaling */
#define ERR_USB_HOST_PORT_RESUME_RECOVERING    (ERR_COMPONET_SPECIFIC + 0x0Bu) /*!< Port generates resume signaling */

/* OTG mode USB specific error codes */
#define ERR_USB_OTG_DISABLED                   (ERR_COMPONET_SPECIFIC + 0x00u) /*!< OTG device is DISABLED state */
#define ERR_USB_OTG_ENABLED_PENDING            (ERR_COMPONET_SPECIFIC + 0x01u) /*!< OTG device is in ENABLED_PENDING state */
#define ERR_USB_OTG_A_IDLE                     (ERR_COMPONET_SPECIFIC + 0x02u) /*!< OTG device is in A_IDLE state */
#define ERR_USB_OTG_A_WAIT_VRISE               (ERR_COMPONET_SPECIFIC + 0x03u) /*!< OTG device is in WAIT_VRISE state */
#define ERR_USB_OTG_A_WAIT_VFALL               (ERR_COMPONET_SPECIFIC + 0x05u) /*!< OTG device is in A_WAIT_VFALL state */
#define ERR_USB_OTG_A_WAIT_BCON                (ERR_COMPONET_SPECIFIC + 0x07u) /*!< OTG device is in A_WAIT_BCON state */
#define ERR_USB_OTG_A_VBUS_ERROR               (ERR_COMPONET_SPECIFIC + 0x09u) /*!< OTG device is in A_VBUS_ERROR state */
#define ERR_USB_OTG_A_SUSPEND                  (ERR_COMPONET_SPECIFIC + 0x0Au) /*!< OTG device is in A_SUSPEND state */

#define ERR_USB_OTG_B_IDLE                     (ERR_COMPONET_SPECIFIC + 0x0Cu) /*!< OTG device is in B_IDLE state */
#define ERR_USB_OTG_B_SRP_INIT                 (ERR_COMPONET_SPECIFIC + 0x0Eu) /*!< OTG device is in B_SRP_INIT state */
#define ERR_USB_OTG_B_WAIT_ACON                (ERR_COMPONET_SPECIFIC + 0x0Fu) /*!< OTG device is in B_WAIT_ACON state */

#define ERR_USB_OTG_A_HOST                     (ERR_COMPONET_SPECIFIC + 0x10u) /*!< OTG device is in A_HOST state */
#define ERR_USB_OTG_A_PERIPHERAL               (ERR_COMPONET_SPECIFIC + 0x11u) /*!< OTG device is in A_PERIPHERAL state */
#define ERR_USB_OTG_B_HOST                     (ERR_COMPONET_SPECIFIC + 0x12u) /*!< OTG device is in B_HOST state */
#define ERR_USB_OTG_B_PERIPHERAL               (ERR_COMPONET_SPECIFIC + 0x13u) /*!< OTG device is in B_PERIPHERAL state */

/*! Device speed symbolic names */
typedef enum {
  LDD_USB_LOW_SPEED     = 0x00u,       /*!< Low-speed - 6 Mb/s mode */
  LDD_USB_FULL_SPEED    = 0x01u,       /*!< Full-speed - 12 Mb/s mode */
  LDD_USB_HIGH_SPEED    = 0x02u,       /*!< High-speed - 480 Mb/s mode */
  LDD_USB_SPEED_UNKNOWN = 0xFFu        /*!< Unkown speed mode */
} LDD_USB_TBusSpeed;

/*! Transfer type symbolic names */
typedef enum {
  LDD_USB_CONTROL      = 0x00u,        /*!< Conrol transfer type */
  LDD_USB_ISOCHRONOUS  = 0x01u,        /*!< Isochronous transfer type */
  LDD_USB_BULK         = 0x02u,        /*!< Bulk transfer type */
  LDD_USB_INTERRUPT    = 0x03u         /*!< Interrupt transfer type */
} LDD_USB_TTransferType;

/*! Transfer state symbolic names */
typedef enum {
  LDD_USB_TRANSFER_NONE               = 0x00u, /*!< Default valeu for new TD */
  LDD_USB_TRANSFER_DONE               = 0x01u, /*!< Transfer done */
  LDD_USB_TRANSFER_ERROR_CANCELLED    = 0x02u, /*!< Transfer cancelled by the user */
  LDD_USB_TRANSFER_ERROR_STALLED      = 0x03u, /*!< Transfer stalled */
  LDD_USB_TRANSFER_ERROR_BUS_TIMEOUT  = 0x04u, /*!< Bus timeute detected */
  LDD_USB_TRANSFER_ERROR_DATA         = 0x05u, /*!< Data error deteceted */
  LDD_USB_TRANSFER_ERROR_PID          = 0x06u, /*!< PID error deteceted */
  LDD_USB_TRANSFER_ERROR_EOF          = 0x07u, /*!< EOF error deteceted */
  LDD_USB_TRANSFER_ERROR_CRC16        = 0x08u, /*!< CRC16 error deteceted */
  LDD_USB_TRANSFER_ERROR_DFN8         = 0x09u, /*!< DFN8 error deteceted */
  LDD_USB_TRANSFER_ERROR_DMA          = 0x0Au, /*!< DMA error deteceted */
  LDD_USB_TRANSFER_ERROR_BTS          = 0x0Bu, /*!< BTS error deteceted */
  LDD_USB_TRANSFER_ERROR              = 0x0Fu, /*!< Transfer error deteceted */
  LDD_USB_TRANSFER_QUEUED             = 0x10u, /*!< Transfer queued */
  LDD_USB_TRANSFER_PENDING            = 0x30u /*!< Transfer in proggress */
} LDD_USB_TTransferState;

/*! Setup data packet structure, uint16_t items must be in little-endian format */
typedef struct LDD_USB_TSDP_Struct {
  uint8_t   bmRequestType;             /*!< Characteristics of request */
  uint8_t   bRequest;                  /*!< Request code */
  uint16_t  wValue;                    /*!< Word-sized field that varies according to request */
  uint16_t  wIndex;                    /*!< Word-sized field that varies according to request, typically used to pass an index or offset */
  uint16_t  wLength;                   /*!< Number of bytes to transfer if there is a data stage */
} LDD_USB_TSDP;

/*! Endpoint descriptor structure, uint16_t items must be in little-endian format */
typedef struct LDD_USB_TEpDescriptor_Struct {
  uint8_t   bLength;                   /*!< Size of this descriptor in bytes */
  uint8_t   bDescriptorType;           /*!< Descriptor type */
  uint8_t   bEndpointAddress;          /*!< Endpoint address */
  uint8_t   bmAttributes;              /*!< Endpoint attributes */
  uint16_t  wMaxPacketSize;            /*!< Maximum packet size the endpoint is capable of sending or receiving */
  uint8_t   bInterval;                 /*!< Interval for polling endpoint for data transfers */
} LDD_USB_TEpDescriptor;

/*! Standard device descriptor structure, uint16_t items must be in little-endian format  */
typedef struct LDD_USB_TDevDescriptor_Struct {
  uint8_t   bLength;                   /*!< Size of this descriptor in bytes */
  uint8_t   bDescriptorType;           /*!< Descriptor type */
  uint16_t  bcdUSB;                    /*!< USB specification release number in binary-coded Decimal */
  uint8_t   bDeviceClass;              /*!< Class code (assigned by the USB-IF) */
  uint8_t   bDeviceSubClass;           /*!< Subclass code (assigned by the USB-IF) */
  uint8_t   bDeviceProtocol;           /*!< Protocol code (assigned by the USB-IF) */
  uint8_t   bMaxPacketSize0;           /*!< Maximum packet size for endpoint zero */
  uint16_t  idVendor;                  /*!< Vendor ID (assigned by the USB-IF) */
  uint16_t  idProduct;                 /*!< Product ID (assigned by the manufacturer) */
  uint16_t  bcdDevice;                 /*!< Device release number in binary-coded decimal */
  uint8_t   iManufacturer;             /*!< Index of string descriptor describing manufacturer */
  uint8_t   iProduct;                  /*!< Index of string descriptor describing product */
